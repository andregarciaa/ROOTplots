Q0. Define what is a docstring.
    - First statement of a module, function, class or method DEFINITION, 
    which documents the code, giving information about what it is doing,  
    which inputs requires, what it will return, etc.
    For a given "functionName", writing "print functionName.__doc__" is 
    possible to see the docstring on screen during execution time.


Q1. Create a dictionary relating the name of all elementary particles 
with its charge (0,-1, or +1). Hint (Under 5.5. Dictionaries): 
https://docs.python.org/2.7/tutorial/datastructures.html
    - Creation and directly addition of keys with their respective values 
     to the dictionary:
elementary_particles={'gluon':0, 'photon':0, 'neutrino':0, 'electron neutrino':0,\
'muon':-1, 'muon neutrino':0, 'tau':-1, 'tau neutrino':0,}

    - Addition of extra values at the end of the dictionary:
elementary_particles['electron']=-1
elementary_particles['higgs']=0
elementary_particles['W boson']=-1
elementary_particles['Z boson']=0
elementary_particles['graviton']=0

    - Note that the order in which you add keys and values to a dictionary
      is not necessary the same as the order in which they are located. 
      Nevertheless, this is not important due to the fact that you access
      values through the name of the keys, not through the positions of 
      the data inside the dictionary (this is the main difference between
      arrays and dictionaries).


Q2. What is a package? (Trick: https://docs.python.org/2.7/tutorial/modules.html)
    - It is a group of modules. It is a way of structuring Python’s module 
    namespace by using “dotted module names”. 
    If "cartera" and "reloj" are modules inside a big module called "persona", 
    the way of accessing them would be like:
    persona.cartera
    persona.reloj


Q3. What is the name of the package to use ROOT in python?
    - The ROOT package in Python is called: ROOT


Q3.1. If you want to use it, what should you do in your code?
      - In order to use it, write at the begining of the script or 
      before the first line where the Pyhton package is used:
      import ROOT


Q4. How is it instantiated a ROOT file?
    - In C++:
    TFile *MyFile = new TFile("File.root","NEW");     
    - In Python:						       
    myfile = ROOT.TFile("file.root")


Q4.1. What is the difference between an instance and a class?
      - A class is an abstract entity, generic, global, while an 
      instance or object (instantiation of a class) is a particular 
      case of a class, with concrete values for its variables.
      Example:
      Class = Person
      Object = Juan


Q5. How is it retrieved (recuperar) an existing object inside a ROOT file?
    - Using the Get() method


Q51.1. Write down the line needed to extract and instantiate the TTree
"alibava_clusters" from any of the "*_beam_analysis_cluster.root" files
       - Generic answer (write the complete name for a particular case):
       "*_beam_analysis_cluster.root".Get("alibava_clusters")


Q6. Check the package https://github.com/duartej/postproc-alibava/ and look 
for a function which can obtain the time window from a TTree. Write down the 
lines of code needed to use it, and use it to obtain the time window of:
'/eos/user/d/duarte/alibavas_data_root/N1-3_0_b1/run000393/393_2017-05-21_17-48_\
gerva_MB2_N1-3_-50V_-76d0uA_-25C_lat132_beam_analysis_cluster.root'
Hint: Check under alibavaSkifftools folder. If you don't have installed the 
package, you should do it
    - From alibavaSkifftools/python/analysis_functions.py script, the lines 
      71-152 calculate the time window through the get_time_window() method:

def get_time_window(tree,cut,\
        win_halfsize=2.0,\
        fog_brname="cluster_charge",time_brname="eventTime",
        fog_min=0,fog_max=500):
    """Get the time window by obtaining the maximum of the 
    time profile 
    
    Parameters
    ----------
    tree: ROOT.TTree
    cut: str
        The cut string to be applied to the selection
    win_halfsize: float, default: 2.0 
        The (half) size of the window around the maximum
    fog_brname: str, optional
        The name of the branch will act as figure of merit
        to extract their maximum (values are averaged vs. x)
    time_brname: str, optional
        The name of the branch will act as x-coordinate 
    fog_min: float
        The min value for the fog in the fit
    fog_max: float
        The max value for the fog in the fit
    """
    import ROOT
    ROOT.gROOT.SetBatch()

    c = ROOT.TCanvas()
    # Check the branches exist
    for brname in [ fog_brname, time_brname ]:
        if brname not in map(lambda x: x.GetName(),tree.GetListOfBranches()):
            raise AttributeError("get_time_window: no branch '{0}' "\
                    "found in the input tree".format(brname))
    # First get the eta-distribution
    tree.Draw("{0}:{1}>>_test(30,-0.5,29.5,100,{2},{3})".format(\
            fog_brname,time_brname,fog_min,fog_max),"{0}".format(cut))
    _h2 = ROOT.gDirectory.Get("_test")
    if type(_h2) == ROOT.TObject:
        raise AttributeError("Histogram generation failed. Probably"\
                " due to some unexisting branch name introduced in the"\
                " cut definition: '{0}'".format(cut))
    _h2.SetDirectory(0)
    prof_window = _h2.ProfileX()
    # Fit a polynomial
    t0=3.0
    t1=30.0
    pol_func = ROOT.TF1("pol_func","pol4",t0,t1)
    status = prof_window.Fit(pol_func,"QS")
    if status.Status() != 0:
        print "[analysis_functions.get_time_window] WARNING : Fit failed"
        ROOT.gROOT.SetBatch(0)
        c.Close()
        return (-1,-1)
    # Find the maximum and define time window as +- 2 ns.
    # To find the maximum df/dt ~= 0
    N = 200
    Dx = (t1-t0)/float(N)
    tmax=0.0
    found_max=False
    last_derivate = pol_func.Derivative(t0)
    for i in xrange(1,N):
        t = t0+i*Dx
        # Change of sign?
        current_derivate =  pol_func.Derivative(t)
        if(current_derivate*last_derivate < 0.0):
            # Get the medium 
            tmax = t-Dx/2.0
            found_max = True
            break
        last_derivate = current_derivate
    # If did not find the maximum, means is monotically
    # creasing or decreasing, take the absolute maximum
    if not found_max:
        # Creasing case
        if pol_func(t0) < pol_func(t1):
            tmax = t1-win_halfsize
        # Decreasing case
        else:
            tmax = t0
    ROOT.gROOT.SetBatch(0)
    c.Close()
    return (tmax-win_halfsize,tmax+win_halfsize)



    - Obtain the time window of:
'/eos/user/d/duarte/alibavas_data_root/N1-3_0_b1/run000393/\
393_2017-05-21_17-48_gerva_MB2_N1-3_-50V_-76d0uA_-25C_lat132_beam_analysis_cluster.root'


Q7. List the names of the ROOT class that defines histograms, functions
and Graphs (in 1Dimension), and instantiate in python code.
    - TH1, TGraph, Draw(), TCanvas()


Q7.1. Identify each case with the right class to use (histogram, function or graph):
   a. The Landau fitted to a charge distribution. 
      - Function
   b. The intensity (I) measured in a circuit given a voltage (v). Perform the 
   measurement 20 times using different 20-voltages.
      - Histogram
   c. The charge of reconstructed clusters in a depleted semiconductor
   sensor, which was iluminated by MIPs in a test-beam.
      - Graph


Q8. Obtain the calibrated charge distribution from the sensor N1-3_0_b1, run 393 
applying the proper time window cut and a common mode cut (no more than 20 ADC). 
Write down the lines of code needed to obtain the plot in a python interpreter.
    - 


Q8.1. Fit the obtained distribution to a Landau*Gaus function. Write down the python 
code. (You can use the Landau-gaus function placed in the postproc-alibava package, 
check in the alibavaSkifftools.analysis_function module, the landau_gaus function and 
use it to build a TF1 function).
WARNING: DIFFICULT PROBLEM
      - 


Q8.2. Obtain the parameters of the fitted function and print out their values, write 
down the python code. 
      - 

