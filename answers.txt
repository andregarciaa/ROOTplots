Q0. Define what is a docstring.
    - First statement of a module, function, class or method DEFINITION,
    which documents the code, giving information about what it is doing,
    which inputs requires, what it will return, etc.
    For a given "functionName", writing "print functionName.__doc__" is
    possible to see the docstring on screen during execution time.
[JDC] RIGHT. So, it is very important to USE IT. A good documentation
      is going to save you (or the you of the future) a lot of headaches
      --> DONE


Q1. Create a dictionary relating the name of all elementary particles
with its charge (0,-1, or +1). Hint (Under 5.5. Dictionaries):
https://docs.python.org/2.7/tutorial/datastructures.html
    - Creation and directly addition of keys with their respective values
     to the dictionary:
elementary_particles={'gluon':0, 'photon':0, 'neutrino':0, 'electron neutrino':0,\
'muon':-1, 'muon neutrino':0, 'tau':-1, 'tau neutrino':0,}

    - Addition of extra values at the end of the dictionary:
elementary_particles['electron']=-1
elementary_particles['higgs']=0
elementary_particles['W boson']=-1
elementary_particles['Z boson']=0
elementary_particles['graviton']=0

    - Note that the order in which you add keys and values to a dictionary
      is not necessary the same as the order in which they are located.
      Nevertheless, this is not important due to the fact that you access
      values through the name of the keys, not through the positions of
      the data inside the dictionary (this is the main difference between
      arrays and dictionaries).
[JDC] RIGHT. Perfect. Now let me complicate a bit, 
Q1.1. Create a dictionary (or many) to allow you to obtain a charge of a particle
      by the kind of elementary particle (lepton or boson) and its name
      Right now you accessing only by its name.


Q2. What is a package? (Trick: https://docs.python.org/2.7/tutorial/modules.html)
    - It is a group of modules. It is a way of structuring Python’s module
    namespace by using “dotted module names”.
    If "cartera" and "reloj" are modules inside a big module called "persona",
    the way of accessing them would be like:
    persona.cartera
    persona.reloj
[JDC]  DONE


Q3. What is the name of the package to use ROOT in python?
    - The ROOT package in Python is called: ROOT
[JDC] DONE


Q3.1. If you want to use it, what should you do in your code?
      - In order to use it, write at the begining of the script or
      before the first line where the Pyhton package is used:
      import ROOT
[JDC] DONE


Q4. How is it instantiated a ROOT file?
    - In C++:
    TFile *MyFile = new TFile("File.root","NEW");
    - In Python:
    myfile = ROOT.TFile("file.root")
[JDC] DONE


Q4.1. What is the difference between an instance and a class?
      - A class is an abstract entity, generic, global, while an
      instance or object (instantiation of a class) is a particular
      case of a class, with concrete values for its variables.
      Example:
      Class = Person
      Object = Juan


Q5. How is it retrieved (recuperar) an existing object inside a ROOT file?
    - Using the Get() method
[JDC] Actually it is not totally correct, (trick: check the signature of 
     the method)


Q51.1. Write down the line needed to extract and instantiate the TTree
"alibava_clusters" from any of the "*_beam_analysis_cluster.root" files
       - Generic answer (write the complete name for a particular case):
       "*_beam_analysis_cluster.root".Get("alibava_clusters")
[JDC] You are using the method Get of a str object ("*_beam_analysis_cluster.root")
      which does not have a Get method


Q6. Check the package https://github.com/duartej/postproc-alibava/ and look
for a function which can obtain the time window from a TTree. Write down the
lines of code needed to use it, and use it to obtain the time window of:
'/eos/user/d/duarte/alibavas_data_root/N1-3_0_b1/run000393/393_2017-05-21_17-48_\
gerva_MB2_N1-3_-50V_-76d0uA_-25C_lat132_beam_analysis_cluster.root'
Hint: Check under alibavaSkifftools folder. If you don't have installed the
package, you should do it
    - From alibavaSkifftools/python/analysis_functions.py script, the lines
      71-152 calculate the time window through the get_time_window() method:

[JDC] Erased innecesary lines. You copied-paste here the implementation of the
      get_time_window method, but what I'm asking is the lines of code you need
      to calculate the time window USING the get_time_window, so you have to 
      use it. To use a method, class, package that somebody else wrote, you 
      don't need to know exactly the implementations, but the INTERFACE methods,
      that's it WHAT they can do for you and HOW you can use them

Q7. List the names of the ROOT class that defines histograms, functions
and Graphs (in 1Dimension), and instantiate in python code.
    - TH1, TGraph, Draw(), TCanvas()


Q7.1. Identify each case with the right class to use (histogram, function or graph):
   a. The Landau fitted to a charge distribution.
      - Function
   b. The intensity (I) measured in a circuit given a voltage (v). Perform the
   measurement 20 times using different 20-voltages.
      - Graph
   c. The charge of reconstructed clusters in a depleted semiconductor
   sensor, which was iluminated by MIPs in a test-beam.
      - Histogram


Q8. Obtain the calibrated charge distribution from the sensor N1-3_0_b1, run 393
applying the proper time window cut and a common mode cut (no more than 20 ADC).
Write down the lines of code needed to obtain the plot in a python interpreter.
    -


Q8.1. Fit the obtained distribution to a Landau*Gaus function. Write down the python
code. (You can use the Landau-gaus function placed in the postproc-alibava package,
check in the alibavaSkifftools.analysis_function module, the landau_gaus function and
use it to build a TF1 function).
WARNING: DIFFICULT PROBLEM
      -


Q8.2. Obtain the parameters of the fitted function and print out their values, write
down the python code.
      -

