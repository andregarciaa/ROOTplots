ANSWERS OF THE QUESTIONS OF comments.txt

Q1: What's a script and a module, what is the difference between them?
    - A script is a code capable of being executed.
    - A module is a part of code with a precise function which works by 
      itself but when being implemented inside a script in order to be 
      able to be executed.
    - Difference: the complexity: modules are functions inside scripts.
[JDC] NOT CORRECT. Check again the definition of module and the difference
                   between them. (Trick: is it intrisically different? maybe 
                   conceptually different?)
[AGA] "A module is a file containing Python definitions and statements", so it 
      is the same as a script, there is no internal distinction. Nevertheless, 
      a module is generally a library, imported by other pieces of code and the 
      filename is used as the basis for the module name; while a script is 
      generally a directly executable piece of code, run by itself and the 
      module is named __main__.
[JDC] CORRECT! --> DONE


Q2: How can you break a line while you are writing a string variable larger 
than 80 char.: "somethingverylongblahblahblabh.."?
    - Ending the line with a back slash "\".
[JDC] CORRECT  --> DONE


Q3: When is it executed that lines? (from "if __name__=='__main__':")
            a. when you run from bash terminal "python root_plots.py"
            b. when you run from python interpreter "import root_plots"
          Why?
    - This part is only executed when we run from the bash terminal, introducing 
      "python root_plots.py". When running from the terminal, we are executing the
      the script as principal program and its variable "__name__" (the name of the 
      program) gets called "__main__". If the code is being imported, this variable 
      takes the name of the script and these lines are never executed.
[JDC] CORRECT. --> DONE


Q4: Show how to check in one line of code how to check if a file exists in 
a given path using
            a. glob module
            b. os.path module
    - With glob, after "import glob":
	 glob.glob('FileName')
      It returns an array with the name of the file if it exists.
	
    - With os.path, after doing "import os.path":
	 os.path.isfile("FileName")    
      It returns True if the file exists.
[JDC] CORRECT. Q4.1. Use either 'glob' or 'os.path' methods to obtain a list 
                     of all the files present at ANY subfolder of the lxplus path:
                     '/eos/user/d/duarte/alibavas_data_root' which ends with the 
                     substring 'beam_analysis_cluster.root'.
                     Write the actual code (which I will copy-paste from here to
                     a python interpreter to see the result).
                     You can do it in one line
[AGA] glob.glob('/eos/user/d/duarte/alibavas_data_root/*/*/*beam_analysis_cluster.root')
[JDC] CORRECT! --> DONE


Q5: Use a str method to check whether or not the substring "myfriend" is in 
the string "dontlooseyourmind_my_friend"
    - One way of checking this is the following: 
      "myfriend" in "dontlooseyourmind_my_friend" 
    - Using a str method: 
      "dontlooseyourmind_my_friend".find("myfriend")
      if it returns -1 value, the string does not contain the substring
[JDC] So, do it explicitely and give me an answer to the Q5
[AGA] "dontlooseyourmind_my_friend".find("myfriend")
[JDC] Missing answer yet
[AGA] "dontlooseyourmind_my_friend".find("myfriend") returns -1 due to "myfriend" is not
      inside the string "dontlooseyourmind_my_friend"
[JDC] CORRECT --> DONE


Q6: In one line, extract the substring 'croack' from the string 
"the_frog_is_saying_croak_but_no_one_is_listening". Trick, check the 
available functions of a python str
    - The substring is saved inside "s":
s = "the_frog_is_saying_croak_but_no_one_is_listening".partition("saying_")[2].partition("_but")[0]
[JDC] CORRECT. Q6.1. Do it using a different method of str 
[AGA] "the_frog_is_saying_croak_but_no_one_is_listening".replace("the_frog_is_saying_","").replace("_but_no_one_is_listening","")
[JDC] CORRECT, another approach (cleaner): "the_frog_is_saying_croak_but_no_one_is_listening".split("_")[4]
      Take note of the 'split' method, it is very useful 
      --> DONE


Q7: You cannot use "root -l path_with_root_file" inside a python script. Why?
    - Because this is a command line, it uses terminal comands defined in $PATH.
[JDC] CORRECT.. partially, what does it means "it uses terminal comands defined in $PATH." ?
[AGA] Terminal comands like "-l" only make sense when executed from the terminal. Environment 
      variable PATH contains where this binary file is located in order to execute it.
      Inside a python script you don't have access to PATH, so neither to "root" or "-l"
      executions.
[JDC] "-l" is not a command, What is it?
      Actually, you are right about you don't have access to PATH, but you are not
      right, about why is not correct to put "root -l path_with_root_file" inside
      the script.
[AGA] Because using terminal comands is equivalent to execute special scripts (eg. "pwd" is
      the same as doing "echo $PWD"), but inside the script they don't have this meaning, 
      we are not even defining them.
[JDC] No. Please answer:
      1. What is "-l" (in "root -l path_with_root_file" as it is not a command? 
      2. Why is not correct to put "root -l path_with_root_file" inside a python script?
         (Trick: launch the line and see what the interpreter tells you)
[AGA] -l is a flag (option which modifies the behaviour of the command ("root" in this case, 
      avoiding the show of the ROOT version information))
      "root -l path_with_root_file" is not correct inside a python script because it launches ROOT, 
      for making possible execute ROOT commands, which makes no sense inside a script.


Q8: Generic example of Q4.1: Use either 'glob', 'os' or 'os.path' methods or standard library module 
    to obtain a list of all the files present at ANY subfolder of the lxplus path:
            '/eos/user/d/duarte/alibavas_data_root' 
    which ends with the substring 'beam_analysis_cluster.root'. We don't know the substructure
    of alibavas_data_root.
[AGA] Changed in Python 3.5: Support for recursive globs using "**":
glob.glob('/eos/user/d/duarte/alibavas_data_root/**/*beam_analysis_cluster.root', recursive=True)
[JDC] CORRECT if our version is 3.5. Now, answer the question for a python 2.7 
[AGA] For Python 2.7:
path = '/eos/user/d/duarte/alibavas_data_root/'
while(glob.glob(path+'*beam_analysis_cluster.root')==[]):
    path = path+'*/'
path = path+'*beam_analysis_cluster.root'
glob.glob(path)
