Q0. Define what is a docstring.
    - First statement of a module, function, class or method DEFINITION,
    which documents the code, giving information about what it is doing,
    which inputs requires, what it will return, etc.
    For a given "functionName", writing "print functionName.__doc__" is
    possible to see the docstring on screen during execution time.
[JDC] RIGHT. So, it is very important to USE IT. A good documentation
      is going to save you (or the you of the future) a lot of headaches
      --> DONE


Q1. Create a dictionary relating the name of all elementary particles
with its charge (0,-1, or +1). Hint (Under 5.5. Dictionaries):
https://docs.python.org/2.7/tutorial/datastructures.html
    - Creation and directly addition of keys with their respective values
     to the dictionary:
elementary_particles={'gluon':0, 'photon':0, 'neutrino':0, 'electron neutrino':0,\
'muon':-1, 'muon neutrino':0, 'tau':-1, 'tau neutrino':0,}

    - Addition of extra values at the end of the dictionary:
elementary_particles['electron']=-1
elementary_particles['higgs']=0
elementary_particles['W boson']=-1
elementary_particles['Z boson']=0
elementary_particles['graviton']=0

    - Note that the order in which you add keys and values to a dictionary
      is not necessary the same as the order in which they are located.
      Nevertheless, this is not important due to the fact that you access
      values through the name of the keys, not through the positions of
      the data inside the dictionary (this is the main difference between
      arrays and dictionaries).
[JDC] RIGHT. Perfect. Now let me complicate a bit: Q1.1


Q1.1. Create a dictionary (or many) to allow you to obtain a charge of a particle
by the kind of elementary particle (lepton or boson) and its name. Right now you 
are accessing only by its name.
      - Due to the big dictionary has only two keys, they are defined by hand, when
        instantiating this dictionary. The value of each key is a dictionary which
        is also instantiated here. I assume we have in memory the dictionary of Q1:

elementary_particles_2 = {"lepton":{}, "boson":{}}
for i in elementary_particles:
    if (i=="electron" or i=="muon" or i=="tau" or i=='electron neutrino' or \
    i=='muon neutrino' or i=='tau neutrino'):
        elementary_particles_2["lepton"][i] = elementary_particles[i]
    else:
        elementary_particles_2["boson"][i] = elementary_particles[i] 


Q2. What is a package? (Trick: https://docs.python.org/2.7/tutorial/modules.html)
    - It is a group of modules. It is a way of structuring Python’s module
    namespace by using “dotted module names”.
    If "cartera" and "reloj" are modules inside a big module called "persona",
    the way of accessing them would be like:
    persona.cartera
    persona.reloj
[JDC]  DONE


Q3. What is the name of the package to use ROOT in python?
    - The ROOT package in Python is called: ROOT
[JDC] DONE


Q3.1. If you want to use it, what should you do in your code?
      - In order to use it, write at the begining of the script or
      before the first line where the Pyhton package is used:
      import ROOT
[JDC] DONE


Q4. How is it instantiated a ROOT file?
    - In C++:
    TFile *MyFile = new TFile("File.root","NEW");
    - In Python:
    myfile = ROOT.TFile("file.root")
[JDC] DONE


Q4.1. What is the difference between an instance and a class?
      - A class is an abstract entity, generic, global, while an
      instance or object (instantiation of a class) is a particular
      case of a class, with concrete values for its variables.
      Example:
      Class = Person
      Object = Juan
[JDC] DONE


Q5. How is it retrieved (recuperar) an existing object inside a ROOT file?
    - Using the Get() method
[JDC] Actually it is not totally correct, (trick: check the signature of 
     the method)
[AGA] The Get() method is overloaded, there are several different signatures
      using this name. In this case, we need the Get(str) method, whose 
      input is a string (the object we want to take from the ROOT file).


Q5.1. Write down the line needed to extract and instantiate the TTree
"alibava_clusters" from any of the "*_beam_analysis_cluster.root" files
       - Generic answer (write the complete name for a particular case):
       "*_beam_analysis_cluster.root".Get("alibava_clusters")
[JDC] You are using the method Get of a str object ("*_beam_analysis_cluster.root")
      which does not have a Get method
[AGA] We cannot take a string and get from it an object, we need first to 
      open the root file, which has that string as name, and save it in a 
      variable, from where we take the object:
import ROOT
rootfile = ROOT.TFile("/eos/user/d/duarte/alibavas_data_root/N1-3_0_b1/run000393/\
393_2017-05-21_17-48_gerva_MB2_N1-3_-50V_-76d0uA_-25C_lat132_beam_analysis_clu\
ster.root")
rootfile.Get("alibava_clusters")


Q6. Check the package https://github.com/duartej/postproc-alibava/ and look
for a function which can obtain the time window from a TTree. Write down the
lines of code needed to use it, and use it to obtain the time window of:
'/eos/user/d/duarte/alibavas_data_root/N1-3_0_b1/run000393/393_2017-05-21_17-48_\
gerva_MB2_N1-3_-50V_-76d0uA_-25C_lat132_beam_analysis_cluster.root'
Hint: Check under alibavaSkifftools folder. If you don't have installed the
package, you should do it
    - From alibavaSkifftools/python/analysis_functions.py script, the lines
      71-152 calculate the time window through the get_time_window() method:

[JDC] Erased innecesary lines. You copied-paste here the implementation of the
      get_time_window method, but what I'm asking is the lines of code you need
      to calculate the time window USING the get_time_window, so you have to 
      use it. To use a method, class, package that somebody else wrote, you 
      don't need to know exactly the implementations, but the INTERFACE methods,
      that's it WHAT they can do for you and HOW you can use them.
[AGA] The first thing we have to do is to work from the directory where 
      postproc-alibava repository has been cloned, and in particular inside it, 
      from /alibavaSkifftools/python. Once there, import the module where the 
      this method (get_time_window()) is stored (without its extension .py): 

import analysis_functions
import ROOT
# Open the ROOT file which contains the data:
rootfile = ROOT.TFile("/eos/user/d/duarte/alibavas_data_root/N1-3_0_b1/run000393/\
393_2017-05-21_17-48_gerva_MB2_N1-3_-50V_-76d0uA_-25C_lat132_beam_analysis_clu\
ster.root")
# Get from the ROOT file the tree we need:
roottree = rootfile.Get("alibava_clusters")
# Use the method to obtain the time window, giving it the tree and where to cut:
analysis_functions.get_time_window(roottree,"eventTime")

      And the resulting window time after the execution of these lines is the following: 
      (9.3025, 13.3025)


Q7. List the names of the ROOT class that defines histograms, functions
and Graphs (in 1Dimension), and instantiate in python code.
    - TH1, TGraph, Draw(), TCanvas()
[JDC] There is errors: TH1 and TGraph are the virtual classes for histograms
      and graphs (what is a virtual class?), but Draw() is a METHOD not a class,
      and TCanvas is nothing to do with histograms, functions nor graphs (what is
      a TCanvas class?)


Q7.1. Identify each case with the right class to use (histogram, function or graph):
   a. The Landau fitted to a charge distribution.
      - Function
   b. The intensity (I) measured in a circuit given a voltage (v). Perform the
   measurement 20 times using different 20-voltages.
      - Graph
   c. The charge of reconstructed clusters in a depleted semiconductor
   sensor, which was iluminated by MIPs in a test-beam.
      - Histogram
[JDC] RIGHT, done


Q8. Obtain the calibrated charge distribution from the sensor N1-3_0_b1, run 393
applying the proper time window cut and a common mode cut (no more than 20 ADC).
Write down the lines of code needed to obtain the plot in a python interpreter.
    -


Q8.1. Fit the obtained distribution to a Landau*Gaus function. Write down the python
code. (You can use the Landau-gaus function placed in the postproc-alibava package,
check in the alibavaSkifftools.analysis_function module, the landau_gaus function and
use it to build a TF1 function).
WARNING: DIFFICULT PROBLEM
      -


Q8.2. Obtain the parameters of the fitted function and print out their values, write
down the python code.
      -


Q9. What does the checkout do?
    - 


Q10. What do you have to do when you want to stop having a file in the repository 
     (which previously was git add)?
     - 

